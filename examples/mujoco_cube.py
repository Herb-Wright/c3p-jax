"""
You gotta install Mujoco for this one:

    uv pip install mujoco mujoco-mjx

And yeah, I know this file is bigger than my implementation of C3+...
"""
import time
from chex import dataclass
import jax.numpy as jnp
import jax
import mujoco
import mujoco.viewer
from mujoco import mjx
import numpy as np

from c3p_jax import LCSMatrices, C3Problem, c3p_jit, create_rho_schedule


T = 8
dt = 0.1
n_iters = 5

# =============================================================================
# The magic happens here.

def main():
    model = mujoco.MjModel.from_xml_string(xml)
    model.opt.timestep = 0.01
    mjx_model = mjx.put_model(model)

    data = mujoco.MjData(model)
    mjx_data = mjx.make_data(mjx_model)
    mjx_data: mjx.Data = mjx.forward(mjx_model, mjx_data)

    nq = mjx_model.nq  # 14
    nv = mjx_model.nv  # 12
    nu = mjx_model.nu  # 6
    
    get_matrices_jit = jax.jit(lambda d: get_matrices(mjx_model, d, dt=dt))
    lcs_system: LCSMatrices = get_matrices_jit(mjx_data.replace(ctrl=jnp.zeros(nu)))

    Q = get_Q(nq, nv)
    R = 0.1 * jnp.eye(nu)
    x0 = jnp.concat([mjx_data.qpos, mjx_data.qvel])
    xd_1d = x0
    xd_1d = xd_1d.at[:3].add(jnp.array([-0.5, 0, 0]))  # we want the block to move!
    xd = jnp.outer(jnp.ones(T+1), xd_1d)

    c3_problem = C3Problem()
    c3_problem.Q = Q
    c3_problem.Qf = Q
    c3_problem.R = R
    c3_problem.set_lcs_matrices(lcs_system)
    c3_problem.x0 = x0
    c3_problem.xd = xd
    var_weights = jnp.ones(c3_problem.n_vars(T))
    var_weights = var_weights.at[-2*T*c3_problem.nc():].set(100.0)
    c3_problem.rho = create_rho_schedule(n_iters, var_weights, 2, 5)

    step_jit = jax.jit(mjx.step)
    t = 0
    with mujoco.viewer.launch_passive(model, data) as viewer:
        while viewer.is_running():
            if t % 10 == 0:
                # Update problem to u=0, x₀=x
                c3_problem.set_lcs_matrices(get_matrices_jit(mjx_data.replace(ctrl=jnp.zeros(nu))))
                c3_problem.x0 = jnp.concat([mjx_data.qpos, mjx_data.qvel])
                # Solve it
                sol = c3p_jit(c3_problem, T, n_iters)
                mjx_data = mjx_data.replace(ctrl=sol.u[0])

            mjx_data = step_jit(mjx_model, mjx_data)
            mjx_cpu = mjx.get_data(model, mjx_data)

            np.copyto(data.qpos, mjx_cpu.qpos)
            np.copyto(data.qvel, mjx_cpu.qvel)
            np.copyto(data.act, mjx_cpu.act)
            np.copyto(data.ctrl, mjx_cpu.ctrl)

            mujoco.mj_forward(model, data)

            viewer.sync()
            t += 1
            time.sleep(0.01)


# =============================================================================
# Down here is chaos (partially generated by Gemini, GPT, and Claude)

def get_Q(nq: int, nv: int):
    Q = 100.0 * np.eye(nq + nv)  # penalize everything
    Q[:7, :7] = 20000 * np.eye(7)  # penalize cube position a lot
    return Q



@dataclass
class ContactInfoJAX:
    points: jnp.ndarray
    frame: jnp.ndarray
    geom_1: jnp.ndarray
    geom_2: jnp.ndarray
    dist: jnp.ndarray
    friction: jnp.ndarray

    def add_contact(
        self, 
        point: jnp.ndarray, 
        frame: jnp.ndarray, 
        geom_1: int, 
        geom_2: int, 
        dist: int, 
        friction: int,
    ) -> None:
        self.points = jnp.vstack([self.points, jnp.array([point])])
        self.frame = jnp.vstack([self.frame, jnp.array([frame])])
        self.geom_1 = jnp.append(self.geom_1, geom_1)
        self.geom_2 = jnp.append(self.geom_2, geom_2)
        self.dist = jnp.append(self.dist, dist)
        self.friction = jnp.append(self.friction, friction)

def anitescu_contact_terms_from_mjx(
    model: mjx.Model,
    data: mjx.Data,
    contact_info: ContactInfoJAX,
    n_friction_directions: int = 4,
):
    """
    Compute Anitescu-style contact terms from MJX simulation state.
    Vectorized over contacts.

    Returns:
      Jn:  (ncon, nv)
      Jt:  (2 * ncon * n_dirs, nv)
      phi: (ncon,)
      mu:  (ncon,)
    """
    ncon = contact_info.points.shape[0]
    nv = model.nv
    n_dirs = n_friction_directions

    if ncon == 0:
        return (jnp.zeros((0, nv)),
                jnp.zeros((0, nv)),
                jnp.zeros((0,)),
                jnp.zeros((0,)))

    # Precompute tangent directions (same for all contacts)
    angles = jnp.linspace(0.0, 2.0 * jnp.pi, n_dirs, endpoint=False)
    cos_a = jnp.cos(angles)
    sin_a = jnp.sin(angles)

    def single_contact(c_point, c_frame, g1, g2, c_dist, c_mu):
        bodyA = jnp.take(model.geom_bodyid, g1)
        bodyB = jnp.take(model.geom_bodyid, g2)
        # Get the FULL spatial Jacobians (translational + rotational)
        Jp_A, _ = mjx.jac(model, data, c_point, bodyA)
        Jp_B, _ = mjx.jac(model, data, c_point, bodyB)
        # Relative Translational and Rotational Jacobians (nv, 3)
        Jp_rel = Jp_A - Jp_B
        frame = jnp.reshape(c_frame, (3, 3))  # (3, 3)
        normal = frame[:, 0]  # (3,)
        t1 = frame[:, 1]  # (3,)
        t2 = frame[:, 2]  # (3,)
        Jn_i = Jp_rel @ normal  # (nv,)
        tdirs = jnp.outer(cos_a, t1) + jnp.outer(sin_a, t2)
        proj_p = jnp.dot(tdirs, Jp_rel.T)
        proj = proj_p  # (n_dirs, nv)
        Jt_i = jnp.concatenate([proj, -proj], axis=0)  # (2*n_dirs, nv)
        return Jn_i, Jt_i, c_dist, c_mu

    # Vectorize across contacts
    Jn, Jt_list, phi, mu = jax.vmap(single_contact)(
    # Jn, Jt_list, phi, mu = jax.vmap(single_contact(mjx_model, mjx_data, cos_a, sin_a))(
        contact_info.points,
        contact_info.frame,
        contact_info.geom_1,
        contact_info.geom_2,
        contact_info.dist,
        contact_info.friction
    )

    # Stack tangential jacobians across contacts
    Jt = jnp.reshape(Jt_list, (2 * ncon * n_dirs, nv))

    return Jn, Jt, phi, mu

def get_matrices(mjx_model: mjx.Model, mjx_data: mjx.Data, dt=0.1) -> LCSMatrices:
    nv = mjx_model.nv
    nu = mjx_model.nu

    mjx_data = mjx.forward(mjx_model, mjx_data)

    contact_info = calc_contact_info_ground_box(mjx_model, mjx_data, 1)
    contact_info.add_contact(*compute_contact_info_ground_sphere(mjx_model, mjx_data, 2))
    contact_info.add_contact(*compute_contact_info_sphere_box(mjx_model, mjx_data, 2, 1))

    Jn, Jt, phi, mu = anitescu_contact_terms_from_mjx(
        mjx_model, mjx_data, contact_info, n_friction_directions=4
    )

    M = mjx.full_m(mjx_model, mjx_data)  # (nv, nv)

    bias = mjx_data.qfrc_bias 
    B_mat = mjx_data._impl.actuator_moment.reshape(nv, nu)

    q_current = mjx_data.qpos
    v_current = mjx_data.qvel
    u_current = mjx_data.ctrl  

    Jf_q, Jf_v, Jf_u = get_f_jacobians(mjx_model, mjx_data)

    qdotNv = get_vNqdot(mjx_model, mjx_data)  # hope this works
    vNqdot = jnp.linalg.pinv(qdotNv)

    A, B, d, d_v = calc_A_B_d_and_dv(Jf_q, Jf_u, Jf_v, dt, q_current, v_current, u_current, qdotNv, B_mat, bias, M)

    D, E, F, H, c = formulate_anitescu_contact_dynamics_vectorized_jax(
        phi, Jn, Jt, Jf_q, Jf_v, Jf_u,
        d_v, vNqdot, qdotNv, contact_info.friction,
        M, dt, contact_info.points.shape[0], 4, mjx_model.nq, mjx_model.nv,
        mjx_model.qpos0
    )

    F = F + 1e-6 * jnp.eye(F.shape[0])  # Add a small ridge to make sure F ≻ 0

    return LCSMatrices(A=A, B=B, D=D, d=d, E=E, F=F, H=H, c=c)



def build_frame_from_normal(normal: jnp.ndarray) -> jnp.ndarray:
    """Build orthonormal 3x3 frame with given normal as first column."""
    normal = normal / (jnp.linalg.norm(normal) + 1e-12)
    arbitrary = jnp.where(
        jnp.abs(normal[2]) < 0.9,
        jnp.array([0.0, 0.0, 1.0]),
        jnp.array([1.0, 0.0, 0.0])
    )
    tangent1 = jnp.cross(normal, arbitrary)
    tangent1 = tangent1 / (jnp.linalg.norm(tangent1) + 1e-12)
    tangent2 = jnp.cross(normal, tangent1)
    return jnp.column_stack([normal, tangent1, tangent2])


def sphere_box_distance(pos_s, radius_s, pos_b, mat_b, halfsize_b):
    """Compute closest points and distance between a sphere and a box."""
    p_local = mat_b.T @ (pos_s - pos_b)
    q_local = jnp.clip(p_local, -halfsize_b, halfsize_b)
    closest_box = pos_b + mat_b @ q_local
    diff = pos_s - closest_box
    dist_vec_norm = jnp.linalg.norm(diff)
    normal = diff / (dist_vec_norm + 1e-12)
    dist = dist_vec_norm - radius_s
    closest_sphere = pos_s - normal * radius_s

    return closest_sphere, closest_box, normal, dist

def compute_contact_info_sphere_box(mjx_model, mjx_data, geom_sphere_id, geom_box_id):
    pos_s = mjx_data.geom_xpos[geom_sphere_id]
    radius_s = mjx_model.geom_size[geom_sphere_id][0]
    pos_b = mjx_data.geom_xpos[geom_box_id]
    mat_b = mjx_data.geom_xmat[geom_box_id].reshape(3, 3)
    halfsize_b = mjx_model.geom_size[geom_box_id]
    p_s, p_b, normal, dist = sphere_box_distance(pos_s, radius_s, pos_b, mat_b, halfsize_b)
    frame = build_frame_from_normal(normal)
    fric = jnp.maximum(mjx_model.geom_friction[geom_sphere_id],
                       mjx_model.geom_friction[geom_box_id])
    return p_s, frame, geom_sphere_id, geom_box_id, dist, fric[0]

def get_quat_deriv_mat(q: jnp.ndarray) -> jnp.ndarray:
    w, x, y, z = q
    # Using dq/dt = 1/2 ω ⊗ q (spatial algebra)
    return 0.5 * jnp.array([  
        [-x, -y, -z],
        [ w, -z,  y],
        [ z,  w, -x],
        [-y,  x,  w]
    ])

def get_vNqdot(mjx_model: mjx.Model, mjx_data: mjx.Data) -> jnp.ndarray:
    """
    Computes Matrix N, with shape (nq, nv) such that: 

        dq/dt = N(q) v
    
    by looping through joints and analytically computing quaternion derivatives.
    """
    
    N = jnp.zeros((mjx_model.nq, mjx_model.nv))
    for i in range(mjx_model.njnt):
        jtype = mjx_model.jnt_type[i]
        qadr = mjx_model.jnt_qposadr[i]
        vadr = mjx_model.jnt_dofadr[i]
        if jtype == 0:  # Free Joint
            N = N.at[qadr:qadr+3, vadr:vadr+3].set(jnp.eye(3))
            q_quat = mjx_data.qpos[qadr+3 : qadr+7]
            E = get_quat_deriv_mat(q_quat)
            N = N.at[qadr+3:qadr+7, vadr+3:vadr+6].set(E)
        elif jtype == 1:  # Ball Joint
            q_quat = mjx_data.qpos[qadr : qadr+4]
            E = get_quat_deriv_mat(q_quat)
            N = N.at[qadr:qadr+4, vadr:vadr+3].set(E)
        elif jtype == 2 or jtype == 3:  # Slide or Hinge
            N = N.at[qadr, vadr].set(1.0)
    return N



def formulate_anitescu_contact_dynamics_vectorized_jax(
    phi, Jn, Jt, Jf_q, Jf_v, Jf_u,
    d_v, vNqdot, qdotNv, mu_,
    M, dt, n_contacts, n_friction_directions, n_q, n_v,
    q_current
):
    """
    JAX/MJX-compatible vectorized version of Anitescu contact dynamics formulation.

    Args:
        phi: (n_contacts,) signed distances
        Jn: (n_contacts, n_v) normal contact Jacobians
        Jt: (2*n_contacts*n_friction_directions, n_v) tangential contact Jacobians
        Jf_q, Jf_v, Jf_u: dynamics Jacobians wrt q, v, u
        d_v: (n_v,) bias term in velocity dynamics
        vNqdot: (n_v, n_q) maps qdot to v
        qdotNv: (n_q, n_v) maps v to qdot
        mu_: (n_contacts,) friction coefficients
        M: (n_v, n_v) mass matrix
        dt: timestep scalar
        n_contacts, n_friction_directions, n_q, n_v: ints
        q_current: (n_q,) current configuration

    Returns:
        D, E, F, H, c — block matrices for Anitescu discrete dynamics.
    """

    n_lambda = 2 * n_contacts * n_friction_directions
    Minv = jnp.linalg.inv(M)

    eye_contacts = jnp.eye(n_contacts)
    ones_dirs = jnp.ones((1, 2 * n_friction_directions))
    E_t = jnp.kron(eye_contacts, ones_dirs)  # (n_contacts, n_lambda)

    mu_vec = jnp.repeat(mu_, 2 * n_friction_directions)
    mu_mat = jnp.diag(mu_vec)

    J_c = E_t.T @ Jn + mu_mat @ Jt

    MinvJ_c_T = Minv @ J_c.T

    D = jnp.zeros((n_q + n_v, n_lambda))
    E = jnp.zeros((n_lambda, n_q + n_v))
    F = jnp.zeros((n_lambda, n_lambda))
    H = jnp.zeros((n_lambda, Jf_u.shape[1]))
    c = jnp.zeros((n_lambda,))

    D = D.at[:n_q, :].set(dt**2 * (qdotNv @ MinvJ_c_T))
    D = D.at[n_q:, :].set(dt * MinvJ_c_T)

    E_q = dt * (J_c @ Jf_q) + (E_t.T @ Jn @ vNqdot) / dt
    E_v = J_c + dt * (J_c @ Jf_v)
    E = E.at[:, :n_q].set(E_q)
    E = E.at[:, n_q:].set(E_v)

    F = F.at[:, :].set(dt * (J_c @ MinvJ_c_T))
    H = H.at[:, :].set(dt * (J_c @ Jf_u))
    c = c.at[:].set(
        (E_t.T @ phi) / dt +
        dt * (J_c @ d_v) -
        (E_t.T @ Jn @ vNqdot @ q_current) / dt
    )

    return D, E, F, H, c


def get_f_jacobians(
    mjx_model: mjx.Model, mjx_data: mjx.Data
) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    """
    Computes the jacobians ∂f/∂q, ∂f/∂v, and ∂f/∂u where
        
        f(q, v, u) = M⁻¹(q) [B u - C(q, v)]

    From the manipulator equation. See "Consensus Complementarity Control for Multicontact MPC" 
    (Aydinoglu et al 2024) for more information.
    """

    def f(q: jnp.ndarray, v: jnp.ndarray, u: jnp.ndarray):
        mjx_data_new = mjx_data.replace(qpos=q, qvel=v, ctrl=u)
        mjx_data_new: mjx.Data = mjx.forward(mjx_model, mjx_data_new)

        M = mjx.full_m(mjx_model, mjx_data_new)
        C = mjx_data_new.qfrc_bias
        B = mjx_data_new._impl.actuator_moment.T
        vdot = jnp.linalg.solve(M, B @ u - C)
        return vdot
    
    Jq, Jv, Ju = jax.jacfwd(f, argnums=(0, 1, 2))(mjx_data.qpos, mjx_data.qvel, mjx_data.ctrl)
    return Jq, Jv, Ju


def calc_A_B_d_and_dv(
    Jf_q: jnp.ndarray, 
    Jf_u: jnp.ndarray, 
    Jf_v: jnp.ndarray, 
    dt: jnp.ndarray, 
    q_current: jnp.ndarray, 
    v_current: jnp.ndarray, 
    u_current: jnp.ndarray, 
    qdotNv: jnp.ndarray,
    B_mat, bias, M
) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    """Compute A, B, d, and d_v for discrete-time contact-free dynamics.

    Args:
        Jf_q: (n_v, n_q) partial of f wrt q
        Jf_u: (n_v, n_u) partial of f wrt u
        Jf_v: (n_v, n_v) partial of f wrt v
        dt: scalar timestep
        q_current: (n_q,)
        v_current: (n_v,)
        u_current: (n_u,)
        qdotNv: (n_q, n_v) map qdot = N(q) v

    Returns:
        A: (n_x, n_x) system matrix
        B: (n_x, n_u) input matrix
        d: (n_x,) bias vector
        d_v: (n_v,) velocity-space bias
    """
    n_q = q_current.shape[0]
    n_v = v_current.shape[0]

    I_q = jnp.eye(n_q)
    I_v = jnp.eye(n_v)

    Jf_qvu_nominal = (Jf_q @ q_current) + (Jf_v @ v_current) + (Jf_u @ u_current)
    f_qvu_nominal = jnp.linalg.solve(M, B_mat @ u_current - bias)
    d_v = f_qvu_nominal - Jf_qvu_nominal

    A_qq = I_q + (dt**2) * (qdotNv @ Jf_q)
    A_qv = dt * qdotNv + (dt**2) * (qdotNv @ Jf_v)
    A_vq = dt * Jf_q
    A_vv = I_v + dt * Jf_v

    A = jnp.block([
        [A_qq, A_qv],
        [A_vq, A_vv],
    ])

    B_qu = (dt**2) * (qdotNv @ Jf_u)
    B_vu = dt * Jf_u
    B = jnp.vstack([B_qu, B_vu])

    d_top = (dt**2) * (qdotNv @ d_v)
    d_bottom = dt * d_v
    d = jnp.concatenate([d_top, d_bottom], axis=0)

    return A, B, d, d_v
    


def compute_contact_info_ground_sphere(
    mjx_model: mjx.Model, mjx_data: mjx.Data, geom_sphere_id: int
) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
    sphere_pos = mjx_data.geom_xpos[geom_sphere_id]
    sphere_radius = mjx_model.geom_size[geom_sphere_id, 0]
    normal = jnp.array([0.0, 0.0, 1.0])
    contact_point = sphere_pos - (normal * sphere_radius)
    dist = sphere_pos[2] - sphere_radius
    frame = build_frame_from_normal(-normal)
    sphere_friction = mjx_model.geom_friction[geom_sphere_id, 0]
    return contact_point, frame, 0, geom_sphere_id, dist, sphere_friction

def calc_contact_info_ground_box(
    mjx_model: mjx.Model, mjx_data: mjx.Data, geom_box_id: int
) -> ContactInfoJAX:
    box_size = mjx_model.geom_size[geom_box_id]
    pos = mjx_data.geom_xpos[geom_box_id]
    rot_matrix = mjx_data.geom_xmat[geom_box_id]
    box_friction = mjx_model.geom_friction[geom_box_id, 0]
    signs = jnp.array([
        [-1, -1, -1],
        [-1, -1,  1],
        [-1,  1, -1],
        [-1,  1,  1],
        [ 1, -1, -1],
        [ 1, -1,  1],
        [ 1,  1, -1],
        [ 1,  1,  1]
    ], dtype=jnp.float32)
    local_corners = signs * box_size  # (8, 3)
    world_corners = (rot_matrix @ local_corners.T).T + pos
    z_values = world_corners[:, 2]
    sorted_indices = jnp.argsort(z_values)
    lowest_indices = sorted_indices[:4] 
    points = world_corners[lowest_indices] # (4, 3)
    dist = points[:, 2] # (4,)
    normals = jnp.tile(jnp.array([0.0, 0.0, -1.0]), (4, 1)) # (4, 3)
    return ContactInfoJAX(
        points=points,
        frame=jax.vmap(build_frame_from_normal)(normals),
        geom_1=jnp.array([0, 0, 0, 0]),
        geom_2=jnp.array([1, 1, 1, 1]),
        dist=dist,
        friction=box_friction * jnp.ones(4)
    )


xml = """<mujoco model="push_cube">
  <option gravity="0 0 -9.81" timestep="0.002"/>

  <asset>
    <texture name="grid" type="2d" builtin="checker" width="512" height="512"
             rgb1=".1 .2 .3" rgb2=".2 .3 .4"/>
    <material name="grid" texture="grid" texrepeat="1 1" texuniform="true" reflectance=".2"/>
  </asset>

  <worldbody>
    <geom name="ground" type="plane" size="2 2 0.1" material="grid" friction="0.3 0.005 0.0001"/>
    <light pos="0 0 3" dir="0 0 -1" diffuse="1 1 1"/>

    <body name="cube" pos="0 0 0.15">
      <freejoint/>
      <geom name="cube_geom" type="box" size="0.15 0.15 0.15"
            rgba="0.8 0.2 0.2 1" mass="5.0" friction="0.3 0.005 0.0001"/>
    </body>

    <body name="sphere" pos="0.30 0 0.15">
      <freejoint name="sphere_joint"/>
      <geom name="sphere_geom" type="sphere" size="0.1"
            rgba="0.2 0.4 0.8 1" friction="0.3 0.007 0.0001"/>
      <inertial pos="0 0 0" mass="1.0" diaginertia="0.5 0.5 0.5"/>
    </body>
  </worldbody>

  <actuator>
    <motor name="force_x" joint="sphere_joint" gear="1 0 0 0 0 0"
           ctrllimited="true" ctrlrange="-100 100"/>
    <motor name="force_y" joint="sphere_joint" gear="0 1 0 0 0 0"
           ctrllimited="true" ctrlrange="-100 100"/>
    <motor name="force_z" joint="sphere_joint" gear="0 0 1 0 0 0"
           ctrllimited="true" ctrlrange="-100 100"/>
    <motor name="torque_x" joint="sphere_joint" gear="0 0 0 1 0 0"
           ctrllimited="true" ctrlrange="-10 10"/>
    <motor name="torque_y" joint="sphere_joint" gear="0 0 0 0 1 0"
           ctrllimited="true" ctrlrange="-10 10"/>
    <motor name="torque_z" joint="sphere_joint" gear="0 0 0 0 0 1"
           ctrllimited="true" ctrlrange="-10 10"/>
  </actuator>
</mujoco>"""






if __name__ == "__main__":
    main()


# Why did you scroll down here?

